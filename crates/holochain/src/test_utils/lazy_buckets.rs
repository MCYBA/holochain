//! Quickly generate a collection of N hashed values whose computed DHT locations
//! are evenly distributed across the space of u32 values.

use std::collections::HashMap;

use crate::*;
use arbitrary::{Arbitrary, Unstructured};
use holo_hash::DhtLocation;
use serde::{Deserialize, Serialize};

/// A "coarse" DHT location specification, defined at a lower resolution
/// than the full u32 space, for convenience in more easily covering the entire
/// space in tests. Splits the u32 space into 256 evenly spaced buckets.
type LocBucket = i8;

/// The total number of items in a collection. This is set to 256 for convenience,
/// but could be changed, or could make this a parameter on a per-collection basis
pub const TOTAL: usize = u8::MAX as usize + 1;
/// The size of each "bucket" represented by each item.
pub const BUCKET_SIZE: usize = ((u32::MAX as u64 + 1) / (TOTAL as u64)) as usize;

type GeneratorFn<T> = Box<dyn Fn() -> T>;
type LocatorFn<T> = Box<dyn Fn(&T) -> DhtLocation>;

/// A set of 256 "buckets" of possible keys/indices, each of which contains a single
/// "representative" value.
pub struct LazyBuckets<T> {
    /// The representative values for each bucket
    pub(super) items: Vec<Option<T>>,
    // /// Reverse lookup map, going from value to its LocBucket
    // pub(super) reverse: HashMap<T, LocBucket>,
    /// How to generate a new value for brute-force searching
    generator: GeneratorFn<T>,
    /// Assigns a LocBucket to each generated value
    locator: LocatorFn<T>,
}

// impl<T: Clone + std::hash::Hash + Eq> LazyBuckets<T> {
//     pub fn lookup(&self, t: &T) -> LocBucket {
//         self.reverse
//             .get(t)
//             .expect("Tried to lookup() a value not generated by LazyBuckets")
//     }
// }

impl<T> LazyBuckets<T> {
    /// Lazily get the item at the specified "bucket".
    /// There are `self.num` buckets, and the index can be a negative number,
    /// which will be counted backwards from `num`.
    pub fn get(&mut self, loc: LocBucket) -> &T {
        let ix = rectify_index(loc);
        while self.items[ix].is_none() {
            let v = (self.generator)();
            let v_loc = ((self.locator)(&v).to_u32() / BUCKET_SIZE as u32) as LocBucket;
            let v_idx = rectify_index(v_loc);
            if self.items[v_idx].is_none() {
                // If we don't have an item at this location, there's no use
                // in throwing it away even if it's not the location we're
                // looking for. Add it to our cache anyway.
                self.items[v_idx] = Some(v);
                // self.reverse.insert(v, v_loc);
            }
        }
        self.items[ix].as_ref().unwrap()
    }

    /// Get the endpoints for the bucket at the specified index
    pub fn bucket(&self, i: LocBucket) -> (DhtLocation, DhtLocation) {
        let bucket_size = BUCKET_SIZE;
        let start = rectify_index(i) * bucket_size;
        (
            DhtLocation::new(start as u32),
            DhtLocation::new((start + bucket_size) as u32),
        )
    }

    /// Construct from generator function
    pub fn new<G, L>(generator: G, locator: L) -> Self
    where
        G: Fn() -> T + 'static,
        L: Fn(&T) -> LocBucket + 'static,
    {
        let mut items = Vec::with_capacity(TOTAL);
        for _ in 0..TOTAL {
            items.push(None);
        }
        Self {
            items,
            // reverse: HashMap::new(),
            generator: Box::new(generator),
            locator: Box::new(locator),
        }
    }
}

/// Map a signed index into an unsigned index
pub fn rectify_index(i: LocBucket) -> usize {
    if i < 0 {
        (TOTAL as isize + i as isize) as usize
    } else {
        i as usize
    }
}
